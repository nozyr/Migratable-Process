Architecture:

There are two important classes implemented in this project: ProcessManager and SlaveNode.

ProcessManager: ProcessManager represents the sever which responsible for task launching, managing and migrating. When
the launch command from user is received, ProcessManager will initialize the task designated by user(in this project we
implemented two classes implementing MigratableProcess, which are ReverseWordList and FactorialProcess) and distribute
the task to SlaveNode to have the task running on SlaveNode. In the middle of task executing, the user can send command
to ProcessManager to suspend and migrate specific running task from one slave node to another.

SlaveNode: The SlaveNode class represents the server which responsible for task executing. The SlaveNode Serve, after
starting, wait for the command from ProcessManager using the accept() method. After the messages from ProcessManager are
received, the SlaveNode cast the received the object as an ProcessMessage object. By using the checkMessage() method the
SlaveNode would be able to know which kind the message belong to. In this project, there are four kind of message that
would be used between ProcessManager and SlaveNode:

1. Launch Message:
   The ProcessManager will always send an serialized Task object along with the Launch Message. By receiving the launch
   Message, the SlaveNode will treat the Task object as a MigratableProcess and start it in a separate thread. After
   starting the task the SlaveNode will add the task id along with the thread project into a hashmap.

2. Suspend Message:
   The ProcessManager will send the task id along with message. The SlaveNode, after receiving the message, will try to
   locate the corresponding task in hashmap. If the task object is found, the SlaveNode will use the suspend() method to
   suspend the task.

3. Restart Message:
   The ProcessManager will send the task id along with message. The SlaveNode, after receiving the message, will try to
   locate the corresponding task in hashmap. If the task object is found, the SlaveNode will use create a new method to
   run the task.

4. Migrate Message:
   The ProcessManager will send the task id along with message. The SlaveNode, after receiving the message, will try to
    locate the corresponding task in hashmap. If the task object is found, the SlaveNode will use the suspend() methond
    to suspend the task and send the task object back to the ProcessManager.



Manual

The process of executing the SlaveNode and ProcessManager is as below:

1. Running the SlaveNode with the argument as below:
    "usage: SlaveNode <portNum> <nodeID>"

   In <portNum> the user specify which port the SlaveNode would use to communicate with ProcessManager. The user can
   launch the SlaveNode multiple times to simulate multiple Slave Server.

2. Running the ProcessManager without any argument, than follow the instruction of given by ProcessManager to launch,
   suspend and migrate task from node to node.